"""
Market Regime Detection
=======================

Identify different market states for dynamic asset allocation.

Methods:
- Hidden Markov Models (HMM)
- Gaussian Mixture Models
- Volatility-based regimes
- Trend-following filters

References:
-----------
- Hamilton, J. (1989). A New Approach to the Economic Analysis of Nonstationary Time Series
- Ang, A. & Timmermann, A. (2012). Regime Changes and Financial Markets
"""

import numpy as np
import pandas as pd
from typing import Dict, List, Optional, Tuple, Literal
from dataclasses import dataclass
from scipy import stats
from scipy.optimize import minimize
import logging

logger = logging.getLogger(__name__)


@dataclass
class Regime:
    """Market regime characteristics."""
    name: str
    mean: float
    volatility: float
    skewness: float
    kurtosis: float
    sharpe: float
    autocorr: float
    var_95: float
    probability: float  # Steady-state probability


class HiddenMarkovModel:
    """
    Hidden Markov Model for regime detection.
    
    Models market returns as generated by hidden states with
transition probabilities.
    """
    
    def __init__(self, n_regimes: int = 2):
        """
        Initialize HMM.
        
        Args:
            n_regimes: Number of hidden states (typically 2-3)
        """
        self.n_regimes = n_regimes
        self.means = None
        self.variances = None
        self.transitions = None
        self.initial_probs = None
        
    def fit(self, returns: pd.Series, n_iter: int = 100) -> 'HiddenMarkovModel':
        """
        Fit HMM using Baum-Welch (EM) algorithm.
        
        Simplified implementation - for production, consider hmmlearn library.
        
        Args:
            returns: Return series
            n_iter: Maximum iterations
            
        Returns:
            self
        """
        # For simplicity, use k-means initialization
        from sklearn.cluster import KMeans
        
        X = returns.dropna().values.reshape(-1, 1)
        
        # Initialize with k-means
        kmeans = KMeans(n_clusters=self.n_regimes, random_state=42, n_init=10)
        labels = kmeans.fit_predict(X)
        
        # Estimate initial parameters
        self.means = np.array([X[labels == i].mean() for i in range(self.n_regimes)])
        self.variances = np.array([X[labels == i].var() + 1e-6 for i in range(self.n_regimes)])
        
        # Initialize transition matrix
        self.transitions = np.ones((self.n_regimes, self.n_regimes)) / self.n_regimes
        for t in range(1, len(labels)):
            self.transitions[labels[t-1], labels[t]] += 1
        self.transitions = self.transitions / self.transitions.sum(axis=1, keepdims=True)
        
        # Initial probabilities
        self.initial_probs = np.array([(labels == i).mean() for i in range(self.n_regimes)])
        
        # EM algorithm (simplified)
        for _ in range(n_iter):
            # E-step: calculate responsibilities
            gamma, xi = self._e_step(X)
            
            # M-step: update parameters
            self._m_step(X, gamma, xi)
        
        return self
    
    def _e_step(self, X: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
        """Expectation step - calculate posterior probabilities."""
        # Flatten X to ensure scalar values
        X_flat = X.flatten()
        T = len(X_flat)
        
        # Forward algorithm
        alpha = np.zeros((T, self.n_regimes))
        alpha[0] = self.initial_probs * self._emission_prob(X_flat[0])
        alpha[0] /= alpha[0].sum()
        
        for t in range(1, T):
            for j in range(self.n_regimes):
                alpha[t, j] = self._emission_prob(X_flat[t], j) * \
                             np.sum(alpha[t-1] * self.transitions[:, j])
            alpha[t] /= alpha[t].sum() + 1e-10
        
        # Backward algorithm
        beta = np.zeros((T, self.n_regimes))
        beta[-1] = np.ones(self.n_regimes)
        
        for t in range(T-2, -1, -1):
            for i in range(self.n_regimes):
                beta[t, i] = np.sum(self.transitions[i] * 
                                   self._emission_prob(X_flat[t+1]) * beta[t+1])
            beta[t] /= beta[t].sum() + 1e-10
        
        # Gamma (state probabilities)
        gamma = alpha * beta
        gamma = gamma / (gamma.sum(axis=1, keepdims=True) + 1e-10)
        
        # Xi (transition probabilities)
        xi = np.zeros((T-1, self.n_regimes, self.n_regimes))
        for t in range(T-1):
            for i in range(self.n_regimes):
                for j in range(self.n_regimes):
                    xi[t, i, j] = alpha[t, i] * self.transitions[i, j] * \
                                 self._emission_prob(X_flat[t+1], j) * beta[t+1, j]
            xi[t] /= xi[t].sum() + 1e-10
        
        return gamma, xi
    
    def _m_step(self, X: np.ndarray, gamma: np.ndarray, xi: np.ndarray):
        """Maximization step - update parameters."""
        T = len(X)
        
        # Update means
        for i in range(self.n_regimes):
            self.means[i] = np.sum(gamma[:, i] * X.flatten()) / (np.sum(gamma[:, i]) + 1e-10)
        
        # Update variances
        for i in range(self.n_regimes):
            diff = X.flatten() - self.means[i]
            self.variances[i] = np.sum(gamma[:, i] * diff**2) / (np.sum(gamma[:, i]) + 1e-10) + 1e-6
        
        # Update transition matrix
        # xi has shape (T-1, n_regimes, n_regimes)
        # Sum over time to get transition counts
        transition_counts = xi.sum(axis=0)  # (n_regimes, n_regimes)
        # Sum over target states to get total from each state
        row_sums = transition_counts.sum(axis=1, keepdims=True)  # (n_regimes, 1)
        self.transitions = transition_counts / (row_sums + 1e-10)
        
        # Update initial probabilities
        self.initial_probs = gamma[0]
    
    def _emission_prob(self, x: float, regime: Optional[int] = None) -> np.ndarray:
        """Calculate emission probability."""
        if regime is not None:
            return stats.norm.pdf(x, self.means[regime], np.sqrt(self.variances[regime]))
        else:
            return np.array([stats.norm.pdf(x, m, np.sqrt(v)) 
                           for m, v in zip(self.means, self.variances)])
    
    def predict_proba(self, returns: pd.Series) -> pd.DataFrame:
        """
        Predict regime probabilities for each time period.
        
        Returns:
            DataFrame with regime probabilities
        """
        X_flat = returns.dropna().values.flatten()
        T = len(X_flat)
        
        # Forward algorithm
        alpha = np.zeros((T, self.n_regimes))
        alpha[0] = self.initial_probs * self._emission_prob(X_flat[0])
        alpha[0] /= alpha[0].sum()
        
        for t in range(1, T):
            for j in range(self.n_regimes):
                alpha[t, j] = self._emission_prob(X_flat[t], j) * \
                             np.sum(alpha[t-1] * self.transitions[:, j])
            alpha[t] /= alpha[t].sum() + 1e-10
        
        columns = [f'Regime_{i}' for i in range(self.n_regimes)]
        return pd.DataFrame(alpha, index=returns.dropna().index, columns=columns)
    
    def predict(self, returns: pd.Series) -> pd.Series:
        """Predict most likely regime for each period."""
        proba = self.predict_proba(returns)
        return proba.idxmax(axis=1)
    
    def get_regime_characteristics(self) -> List[Regime]:
        """Get characteristics of each regime."""
        regimes = []
        
        # Steady-state probabilities
        eigvals, eigvecs = np.linalg.eig(self.transitions.T)
        steady = eigvecs[:, np.argmin(np.abs(eigvals - 1))]
        steady = steady / steady.sum()
        
        for i in range(self.n_regimes):
            regimes.append(Regime(
                name=f'Regime_{i}',
                mean=self.means[i],
                volatility=np.sqrt(self.variances[i]),
                skewness=0,  # Normal distribution assumed
                kurtosis=3,  # Normal distribution assumed
                sharpe=self.means[i] / np.sqrt(self.variances[i]) if self.variances[i] > 0 else 0,
                autocorr=0,  # Would need to calculate from data
                var_95=stats.norm.ppf(0.05, self.means[i], np.sqrt(self.variances[i])),
                probability=steady[i]
            ))
        
        return regimes


class RegimeBasedAllocation:
    """
    Dynamic asset allocation based on detected regimes.
    """
    
    def __init__(self, returns: pd.DataFrame):
        self.returns = returns
        self.regimes = None
        self.optimal_weights = {}
        
    def fit_regimes(self, method: str = 'hmm', n_regimes: int = 2):
        """
        Fit regime detection model.
        
        Args:
            method: 'hmm', 'volatility', or 'trend'
            n_regimes: Number of regimes
        """
        if method == 'hmm':
            # Use portfolio returns for regime detection
            port_returns = self.returns.mean(axis=1)
            hmm = HiddenMarkovModel(n_regimes).fit(port_returns)
            self.regimes = hmm.predict(port_returns)
            self.regime_model = hmm
        elif method == 'volatility':
            # Simple volatility-based regime
            vol = self.returns.std(axis=1).rolling(21).mean()
            self.regimes = (vol > vol.median()).astype(int).apply(lambda x: f'Regime_{x}')
        elif method == 'trend':
            # Trend-based regime
            trend = self.returns.mean(axis=1).rolling(63).mean()
            self.regimes = (trend > 0).astype(int).apply(lambda x: f'Regime_{x}')
    
    def calculate_regime_optimal_weights(self, 
                                        risk_aversion: float = 2.0,
                                        constraints: Optional[Dict] = None):
        """
        Calculate optimal weights for each regime.
        
        Uses mean-variance optimization within each regime.
        """
        for regime in self.regimes.unique():
            mask = self.regimes == regime
            regime_returns = self.returns[mask]
            
            if len(regime_returns) < 30:
                continue
            
            mu = regime_returns.mean() * 252
            Sigma = regime_returns.cov() * 252
            
            # Mean-variance optimization
            from scipy.optimize import minimize
            
            n = len(mu)
            
            def negative_utility(w):
                port_return = w @ mu
                port_var = w @ Sigma @ w
                return -(port_return - 0.5 * risk_aversion * port_var)
            
            cons = [{'type': 'eq', 'fun': lambda w: np.sum(w) - 1}]
            bounds = [(0, 1) for _ in range(n)]
            
            result = minimize(negative_utility, np.ones(n)/n, 
                            method='SLSQP', bounds=bounds, constraints=cons)
            
            if result.success:
                self.optimal_weights[regime] = dict(zip(self.returns.columns, result.x))
    
    def get_current_regime_weights(self, recent_data: pd.DataFrame) -> Dict[str, float]:
        """
        Get optimal weights for current regime.
        
        Args:
            recent_data: Recent returns to determine current regime
            
        Returns:
            Dictionary of optimal weights
        """
        if hasattr(self, 'regime_model'):
            # Use HMM to predict current regime
            current_regime = self.regime_model.predict(recent_data.mean(axis=1))[-1]
        else:
            # Use simple rule
            current_regime = self.regimes.iloc[-1]
        
        return self.optimal_weights.get(current_regime, 
                                       dict(zip(self.returns.columns, 
                                               np.ones(len(self.returns.columns))/len(self.returns.columns))))


class TrendFollowingFilter:
    """
    Trend-following regime filter using moving averages.
    """
    
    def __init__(self, fast: int = 50, slow: int = 200):
        self.fast = fast
        self.slow = slow
        
    def get_signal(self, prices: pd.Series) -> pd.Series:
        """
        Generate trend signals.
        
        Returns:
            Series with values: 1 (bull), 0 (neutral), -1 (bear)
        """
        fast_ma = prices.rolling(self.fast).mean()
        slow_ma = prices.rolling(self.slow).mean()
        
        signal = pd.Series(0, index=prices.index)
        signal[fast_ma > slow_ma] = 1  # Bull
        signal[fast_ma < slow_ma] = -1  # Bear
        
        return signal
    
    def get_regime_returns(self, returns: pd.Series, prices: pd.Series) -> pd.DataFrame:
        """Analyze returns by regime."""
        signal = self.get_signal(prices)
        
        bull_returns = returns[signal == 1]
        bear_returns = returns[signal == -1]
        
        return pd.DataFrame({
            'Bull': {
                'mean': bull_returns.mean(),
                'volatility': bull_returns.std(),
                'sharpe': bull_returns.mean() / bull_returns.std() if bull_returns.std() > 0 else 0,
                'count': len(bull_returns)
            },
            'Bear': {
                'mean': bear_returns.mean(),
                'volatility': bear_returns.std(),
                'sharpe': bear_returns.mean() / bear_returns.std() if bear_returns.std() > 0 else 0,
                'count': len(bear_returns)
            }
        })


def detect_market_regimes(returns: pd.DataFrame, 
                         n_regimes: int = 2,
                         method: str = 'hmm') -> pd.DataFrame:
    """
    Convenience function to detect market regimes.
    
    Args:
        returns: Returns DataFrame
        n_regimes: Number of regimes
        method: 'hmm', 'volatility', or 'gmm'
        
    Returns:
        DataFrame with regime assignments and characteristics
    """
    if method == 'hmm':
        # Use portfolio-level HMM
        port_returns = returns.mean(axis=1)
        hmm = HiddenMarkovModel(n_regimes).fit(port_returns)
        regime_probs = hmm.predict_proba(port_returns)
        regimes = hmm.predict(port_returns)
        
        result = pd.DataFrame({
            'regime': regimes,
            'portfolio_return': port_returns
        })
        
        for col in regime_probs.columns:
            result[f'{col}_prob'] = regime_probs[col]
        
        return result
    
    elif method == 'gmm':
        from sklearn.mixture import GaussianMixture
        
        X = returns.mean(axis=1).values.reshape(-1, 1)
        gmm = GaussianMixture(n_components=n_regimes, random_state=42)
        labels = gmm.fit_predict(X)
        
        return pd.DataFrame({
            'regime': [f'Regime_{l}' for l in labels],
            'portfolio_return': returns.mean(axis=1).values,
            'regime_prob': gmm.predict_proba(X).max(axis=1)
        }, index=returns.index)
    
    else:
        raise ValueError(f"Unknown method: {method}")
